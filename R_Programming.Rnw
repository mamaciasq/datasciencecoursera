\documentclass{article}
\usepackage[utf8]{inputenc}

\title{R Programming}
\author{Martín Macías}
\date{Diciembre de 2015}

\begin{document}

\maketitle

\section{Estableciendo el Directorio de trabajo}
La idea es hacer el seguimiento de los comandos en \texttt{R} para establecer el directorio de trabajo.\\
\begin{itemize}
  \item Con la opción \texttt{getwd()} se obtiene el directorio de trabajo actual:
    <<comment=NA>>=
      getwd()
    @

  \item Para ver los archivos  carpetas que hay en el directorio de trabajo actual:
    <<comment=NA>>=
      dir()
    @

  \item El comando \texttt{ls()} muestra lo que exista en mi espacio de trabajo:
    <<comment=NA>>=
      ls()
    @
\end{itemize}

\section{Data types}
  \subsection{Vectores y listas}
    \subsubsection{Creando vectores}
      La función \texttt{c()} se usa para crear vectores de objetos:
        <<comment=NA>>=
          x <- c(0.5, 0.6)      # Numérico
          x <- c(TRUE, FALSE)   # Lógico
          x <- c(T, F)          # Lógico
          x <- c("a", "b","c")  # Caracter
          x <- 9:29             # Entero
          x <- c(1+0i, 2+4i)    # Complejo
        @

      Usando la función \texttt{vector()}
        <<comment=NA>>=
          x <- vector("numeric", length = 10)
          x
        @

    \subsubsection{Mezclando objetos}
      Miremos cómo se mezclan objetos en un vector
        <<comment=NA>>=
          y <- c(1.7, "a")    # Caracter
          y <- c(TRUE, 2)     # Numérico
          y <- c("a", TRUE)   # Caracter
        @      

    \subsubsection{Concatenación explícita}
      Los objetos pueden concatenarse explícitamente de una clase a otra usando las funciones \texttt{as.*}, si están disponibles:
        <<comment=NA>>=
          x <- 0:6
          class(x)
          as.numeric(x)
          as.logical(x)
          as.character(x)
        @      

      La concatenación sinsentido resulta en \texttt{NAs}
        <<comment=NA>>=
          x <- c("a", "b", "c")
          class(x)
          as.numeric(x)
          as.logical(x)
          as.complex(x)
        @ 

  \subsection{Listas}
    Las listas son tipos de vectores especiales que pueen contener elementos de diferentes clases.
      <<comment=NA>>=
        x <- list(1, "a", TRUE, 1 + 4i)
        x
      @     

  \subsection{Matrices}
    Las matrices son vectores con un atributo de dimensión. El atributo de dimensión es, en sí mismo, un vector entero de longitud 2 \texttt{(nrow, ncol)}
      <<comment=NA>>=
        m <- matrix(nrow = 2, ncol = 3)
        m
        dim(m)
        attributes(m)
      @     

    Las matrices se contruyen en el sentido de las columnas, es decir, en forma de "zig zag" invertido
      <<comment=NA>>=
        m <- matrix(1:6, nrow = 2, ncol = 3)
        m
      @     

    Las matrices también pueden crearse directamente de vectores añadiendo el atributo de dimensión
      <<comment=NA>>=
        m <- 1:10
        m
        dim(m) <- c(2, 5)
        m
      @         

    Las matrices también pueden crearse mediante la unión de filas \texttt{rbind()} o la unión de columnas \texttt{cbind}
      <<comment=NA>>=
        x <- 1:3
        y <- 10:12
        cbind(x ,y)
        rbind(x, y)
      @

  \subsection{Factores}
    Los factores se usan para representar datos categóricos. Los factores pueden ser ordenados o desordenados.
      \begin{itemize}
        \item Los factores son utilizados especialmente para modelar funciones como                \texttt{lm()} y \texttt{glm()}
        \item Usar factores con labels es mejor que usar enteros puesto que los factores son autodescriptivos; tener una variable que tenga como valores <<Masculino>> y <<Femenino>> es mejor que tener una variable con 1 y 2.
      \end{itemize}
      <<comment=NA>>=
        x <- factor(c("yes", "yes", "no", "yes", "no"))
        x
        table(x)    # Hace conteo de niveles que hay 
        unclass(x)  # Despoja de la clase que tenga el vector
      @

    El orden de los niveles se puede determinar usando el argumento \texttt{levels} en \texttt{factor()}. Esto puede ser importante en modelación lineal porque el primer nivel se usa como nivel de base.
      <<comment=NA>>=
        x <- factor(c("yes", "yes", "no", "yes", "no"), 
                    levels = c("yes", "no"))
        x
      @

  \subsection{Datos faltantes}
    Los datos faltantes se denotan por \texttt{NA} o \texttt{NaN} para operaciones matemáticas indefinidas.
      \begin{itemize}
        \item \texttt{is.na()} se usa para probar si los objetos son \texttt{NA}
        \item \texttt{is.nan()} se usa para probar si los objetos son \texttt{NaN}
        \item Los valores \texttt{NA} también tienen clase. Pueden ser enteros                     \texttt{NA}, caracter \texttt{NA}, etc.
        \item Un valor \texttt{NaN} es también \texttt{NA} pero el recíproco no es                 cierto
      \end{itemize}
      <<comment=NA>>=
        x <- c(1, 2, NA, 10, 3)
        is.na(x)
        is.nan(x)
        x <- c(1, 2, NaN, NA, 4)
        is.na(x)
        is.nan(x)
      @

  \subsection{Data frames}
    Los data frames se usan para almacenar datos tabulados.
      \begin{itemize}
        \item Se representan como un tipo especial de lista donde cada elemento de la lista debe tener la misma longitud.
        \item Cada elemento de la lista se puede pensar como una columna y la longitud de cada elemento de la lista es el número de filas.
        \item A diferencia de las matrices, los data frames pueden almacenar diferentes clases de objetos en cada columna (así como las listas): los elementos de las matrices deben ser de la misma clase.
        \item Los data frames también tienen un atributo especial llamado 
              \texttt{row.names}
        \item Los data frames se crean usualmente mediante \texttt{read.table()} o                 \texttt{read.csv()}
        \item Los data frames pueden convertirse en matrices mediante 
              \texttt{data.matrix()}
      \end{itemize}
      <<comment=NA>>=
        x <- data.frame(foo = 1:4, bar = c(T, T, F, F))
        x
        nrow(x)
        ncol(x)
      @
    
  \subsection{Atributos de nombre}
    Los objetos en \texttt{R} también pueden tener nombres, los cuales son muy útiles para esribir código legible y objetos autodescriptivos.
      <<comment=NA>>=
        x <- 1:3
        names(x)
        names(x) <- c("foo", "bar", "norf")
        x
        names(x)
      @

    Las listas también pueden tener nombres.
      <<comment=NA>>=
        x <- list(a = 1, b = 2, c = 3)
        x
      @

    Para las matrices funciona de igual forma.
      <<comment=NA>>=
        m <- matrix(1:4, nrow = 2, ncol = 2)
        dimnames(m) <- list(c("a", "b"), c("c", "d"))
        m
      @    
\section{Leer datos tabulados}
Existen unas pocas funciones principales para leer datos en \texttt{R}.
  \begin{itemize}
    \item \texttt{read.table} y \texttt{read.csv} para leer datos tabulados.
    \item \texttt{readLines} para leer líneas de texto.
    \item \texttt{source} para leer archivos de \texttt{R} (\texttt{inverse} de                \texttt{dump})
    \item \texttt{dget} para leer archivos de \texttt{R} (\texttt{inverse} de                  \texttt{dput})
    \item \texttt{load} para leer de espacios de trabajo guardados
    \item \texttt{unserialize} para leer objetos de \texttt{R} en forma binaria.
  \end{itemize}

  \subsection{\texttt{read.table}}
  La función \texttt{read.table} es una de las funciones más comúnmente usadas para leer datos. Tienen unos pocos argumentos:
  \begin{itemize}
    \item \texttt{file}, el nombre de un archivo o conexión.
    \item \texttt{header}, tipo lógico e indica si el archivo tiene línea de cabecera
    \item \texttt{sep}, tipo cadena e indica cómo están separadas las columnas.
    \item \texttt{colClasses}, un vector de caracteres que indica la clase de cada columna en el conjunto de datos.
    \item \texttt{nrows}, número de filas en el conjunto de datos.
    \item \texttt{comment.char}, una cadena de caracteres que indica el caracter del comentario.
    \item \texttt{skip}, número de líneas que deben omitirse desde el principio.
    \item \texttt{stringsAsFactors}, ¿deberían las variables caracter ser codificadas como factores?
\end{itemize}

\textbf{Nota:} \texttt{read.table} trabaja con archivos separados por espacios mientras que \texttt{read.csv} trabaja con archivos separados por comas.

  \subsection{Usando \texttt{read.table}}
  El argumento \texttt{colClasses} acelera el uso de la función \texttt{read.table} hasta casi el doble. Para usar esta opción, debe conocerse la clase de cada columna de su data frame. Si todas las columnas son numéricas, por ejemplo, entonces debe ajustar el argumento así: \texttt{colClasses = "numeric"}. 
      <<comment=NA, eval = F>>=
        initial <- read.table("datatable.txt", nrows = 100)
        classes <- sapply(initial, class)
        tabAll <- read.table ("datatable.txt", colClasses = classes)
      @
  
  Si configura \texttt{nrows} podrá ahorrar memoria. Puede usar la herramienta de Unix \texttt{wc} para calcular las líneas en un archivo.
  
  \subsection{Formatos de datos textuales}
  \begin{itemize}
    \item \texttt{dumping} y \texttt{dputing} son muy útiles porque el formato textual resultante es editable y en caso de que se corrompan, potenciablemente recuperable.
    \item A diferencia de trabajar con una tabla o con un archivo csv, las funciones \texttt{dumping} y \texttt{dputing} conservan los metadatos (sacrificando algo de legibilidad) para que otro usuario no tenga que especificar todo de nuevo.  
    \item Los formatos textuales pueden trabajar mucho mejor con programas de control de versiones, los cuales pueden rastrear cambios significativos es archivos de texto.
    \item Los archivos textuales pueden ser más duraderos; en casod e que se corrompan, es más fácil hallar el problema dentro del archivo.
    \item \textbf{Desventaja:} El formato no es eficiente en cuanto a ahorro de espacio.
  \end{itemize}

  \subsection{\texttt{dput}-ing objetos en \texttt{R}}
        <<comment=NA>>=
        options(width = 55)
        y <- data.frame(a = 1, b = "a")
        dput(y)
        dput(y, file="y.R")
        new.y <- dget("y.R")
        new.y
      @
  \subsection{\texttt{dump}-ing objetos en \texttt{R}}
      <<comment=NA>>=
        x <- "foo"
        y <- data.frame(a = 1, b = "a")
        dump(c("x", "y"), file = "data.R")
        rm(x, y)
        source("data.R")
        y
        x
      @

  \subsection{Conexiones a archivos}
        <<comment = NA, echo = 2>>=
        options(width = 60)
        str(file)
      @
  \begin{itemize}
    \item \texttt{description} es el nombre del archivo.
    \item \texttt{open} es un incador de código.
      \begin{itemize}
        \item "r" para únicamente lectura
        \item "w" escritura e iniciando un nuevo archivo
        \item "a" anexar
        \item "rb", "wb", "ab" leer, escribir y anexar en modo Binario (Windows) 
      \end{itemize}
  \end{itemize}
  
  \subsection{Conexiones}
  En general, las conexiones son herramientas poderosas para navegar entre archivos u otros objetos. En la práctica, no se necesita enfrentarse directamente con la interfaz de conexión. 
      <<comment = NA, eval = F>>=
        con <- file("foo.txt", "r")
        data <- read.csv(con)
        close(con)
      @

es lo mismo que
      <<comment = NA, eval = F>>=
        data <- read.csv("foo.txt")
      @

  \subsection{Leer líneas de un archivo de texto}
      <<comment = NA, eval = F>>=
        con <- gzfile("words.gz")
        x <- readLines(con, 10)
      @
  \texttt{writeLines} toma un vector de caracteres y escribe cada elemento de una línea al tiempo en un archivo de texto.
  
  \texttt{readLines} puede ser útil para leer líneas de páginas web.
      <<comment = NA>>=
        ## Esto puede tomar algunos minutos
        con <- url("http://www.jhsph.edu", "r")
        x <- readLines(con)
        head(x)
      @

  \subsection{Subconjunto}
  Existen un gran número de operadores que pueden usarse para extraer subconjuntos de objetos en \texttt{R}. 
  \begin{itemize}
    \item \texttt{[ ]} siempre arroja un objeto de la misma clase del original; puede usarse para seleccionar más de un elemento (hay una excepción).
    \item \texttt{[[ ]]} se usa para extraer elementos de una lista o de un data frame; únicamente puede usarse un solo elemento y la clase del objeto obtenido no necesariamente es una lista o un data frame.
    \item \texttt{\$} se usa para extraer elementos de una lista o un data frame por nombre; la semántica es igual a la de \texttt{[[ ]]}.
  \end{itemize}

      <<comment = NA>>=
        x <- c("a", "b", "c", "c", "d", "a")
        x[1]
        x[2]
        x[1:4]
        x[x > "a"]
        u <- x > "a"
        u
        x[u]
      @

  \subsubsection{Listas de Subconjuntos}
      <<comment = NA>>=
        x <- list(foo = 1:4, bar = 0.6)
        x[1]
        x[[1]]
        x$bar
        x[["bar"]]
        x["bar"]
      @

      <<comment = NA>>=
        x <- list(foo = 1:4, bar = 0.6, baz = "hello")
        x[c(1, 3)]
      @

El operador \texttt{[[]]} puede usarse con índices computados; \texttt{\$} puede usarse exclusivamente con nombres literales.
      <<comment = NA>>=
        x <- list(foo = 1:4, bar = 0.6, baz = "hello")
        name <- "foo"
        x[[name]]   ## índice computado para 'foo'
        x$name      ## ¡el elemento 'name' no existe!
        x$foo
      @

\texttt{[[]]} puede tomar una secuencia de enteros.
      <<comment = NA>>=
        x <- list(a = list(10, 12, 14), b = c(3.14, 2.81))
        x[[c(1, 3)]]
        x[[1]][[3]]
        x[[c(2, 1)]]
      @

    \subsubsection{Matrices}
    De las matrices se puede crear también subconjuntos de la forma usual, con índices de la forma \textit{(i, j)}
      <<comment = NA>>=
        x <- matrix(1:6, 2, 3)
        x[1, 2]
        x[2,1]
      @
  
    U omitir los índices si se quiere:
      <<comment = NA>>=
        x[1, ]
        x[ ,2]
      @

    Por defecto, cuando un elemento solo de una matriz es recuperado, éste se retorna como un vector de longitud 1 en vez de ser una matriz de dimensión 1 x 1. Este proceder puede ser modificado mediante el argumento \texttt{drop = FALSE}
      <<comment = NA>>=
        x <- matrix(1:6, 2, 3)
        x[1, 2]
        x[1, 2, drop = FALSE]
      @

    De la misma manera, al hacer subconjuntos de una sola columna o una sola fila, el programa arrojará un vector, no una matriz (por defecto)
      <<comment = NA>>=
        x[1, ]
        x[1, , drop = FALSE]
        x[2,1]
      @

    \subsubsection{Subconjuntos con nombres}
    La coincidencia parcial de nombres se permite con \texttt{[[]]} y \texttt{\$}
      <<comment = NA>>=
        x <- list(aardvark = 1:5)
        x$a
        x[["a"]]
        x[["a", exact = FALSE]]
      @    
    
    \subsubsection{Eliminando valores faltantes}
    Una tarea común es eiminar valores faltantes \texttt{(NAS)}.
      <<comment = NA>>=
        x <- c(1, 2, NA, 4, NA, 5)
        bad <- is.na(x)
        x[!bad]
      @

    ¿Y qué pasaría si existen multiples cosas y usted quiere tomar el subconjunto con los valores no faltantes?
      <<comment = NA>>=
        x <- c(1, 2, NA, 4, NA, 5)
        y <- c("a", "b", NA, "d", NA, "f")
        good <- complete.cases(x, y)
        good
        x[good]
        y[good]
      @    

      <<comment = NA>>=
        airquality[1:6, ]
        good <- complete.cases(airquality)
        airquality[good, ][1:6, ]
      @

\section{Operaciones vectorizadas}
Muchas operaciones en \texttt[R] son \textit{vectorizadas} volviendo el código más eficiente, conciso y fácil de leer.
      <<comment = NA>>=
        x <- 1:4; y <- 6:9
        x + y
        x > 2
        x >= 2
        y == 8
        x * y
        x / y
      @
      
      <<comment = NA>>=
        x <- matrix(1:4, 2, 2); y <- matrix(rep(10, 4), 2, 2)
        x * y   ## Multiplicación término a término
        x / y
        x %*% y ## Multiplicación real de matrices
      @

\section{Estructuras de control}
  \subsection{Introducción}
  Las estructuras de control en \texttt{R} permiten controlar el flujo de ejecución del programa, dependiendo de las condiciones del tiempo de ejecución. Las estructuras más comunes son:
  \begin{itemize}
    \item \texttt{if, else}: para probar una condición
    \item \texttt{for}: ejecuta un bucle un número fijo de veces
    \item \texttt{while}: ejecuta un bucle 'mientras' una condición sea verdadera
    \item \texttt{repeat}: ejecuta un bucle indefinidamentre
    \item \texttt{break}: rompe la ejecución de un bucle
    \item \texttt{next}: omite la interacción de un bucle
    \item \texttt{return}: sale de una función
  \end{itemize}

  \subsection{\texttt{if-else}}
  <<comment = NA, eval = F>>=
    if(<condición>) {
            ## haga algo
    } else {
            # haga algo más
    }
    if(<condición1>) {
            ## haga algo 
    } else if (<condición2>) {
            ## haga algo diferente
    } else {
            ## haga algo diferente
    }
  @

  Esta es una estructura \texttt{if/else} válida:
  <<include = FALSE, cache = FALSE>>=
  muffleError <- function (x, options) {}
  knit_hooks$set(error=muffleError)
  @  
  <<comment = NA>>=
    if(x  > 3) {
            y <- 10
    } else {
            y <- 0
    }
  @

  o esta:  
  <<include = FALSE, cache = FALSE>>=
  muffleError <- function (x, options) {}
  knit_hooks$set(error=muffleError)
  @
  <<comment = NA>>=
    y <- if(x  > 3) {
            10
    } else {
            0
    }
  @

  Obviamente, \texttt{else} no es estrictamente necesario:
  <<comment = NA, eval = FALSE>>=
    if(<condición1>) {

    } 
    if(<condición2>) {

    }
  @  

  \subsection{Bucles \texttt{for}}
  Los bucles \texttt{for} toma una variable iteradora a quien le es asignada valores sucesivos de un vector o una secuencia. Los bucles \texttt{for} son comúnmente usados para iterar sobre los elementos de un objeto (lista, vector, etc.)
  <<comment = NA>>=
    for(i in 1:10){
      print(i)
    }
  @ 
  Este bucle toma la variable \texttt{i} y en cada iteración del bucle le da el valor de 1, 2, 3, $\ldots$, 10 y luego sale del bucle.
  
  Los siguentes tres bucles hacen lo mismo:
  <<comment = NA>>=
    x <- c("a", "b", "c", "d")
    
    for(i in 1:4){
      print(x[i])
    }
  
    for(i in seq_along(x)){
      print(x[i])
    }
    
    for(letter in x){
      print(letter)
    }
    
    for(i in 1:4) print(x[i])
  @ 
  
  Los bucles \texttt{for} pueden estar anidados
  <<comment = NA>>=
    x <- matrix (1:6, 2, 3)
    for(i in seq_len(nrow(x))){
      for(j in seq_len(ncol(x))){
        print(x[i, j])
      }
    }
  @ 
  Hay que tener cuidado con los bucles anidados. Anidar más allá de dos o tres pasos muchas veces difícil de leer o entender.
  
  \subsection{Bucles \texttt{while}}
  Los bucles \texttt{while} comienzan con una condición a evaluar. Si la condición es cierta, ejecutan un cuerpo del bucle. Una vez ese cuerpo es ejecutado, la condición es evaluada nuevamente, etc.
  <<comment = NA>>=
    count <- 0
    while(count < 10){
      print(count)
      count <- count + 1
    }
  @
Los bucles \texttt{while} pueden resultar potencialmente en bucles infinitos si no se escriben apropiadamente. Hay que usarlo con cuidado.

Puede haber más de una condición para evaluar.
  <<comment = NA, eval = FALSE>>=
    z <- 5
    while(z >= 3 && z <= 10){
      print(z)
      coin <- rbinom(1, 1, 0.5)
      
      if(coin == 1) { ## caminata aleatoria
        z <- z + 1
      } else {
        z <- z - 1
      }
    }
  @
  Las condiciones siempre se evalúan de izquierda a derecha.
  
  \subsection{\texttt{repeat}, \texttt{next} y \texttt{break}}
    \subsubsection{\texttt{repeat}}
    \texttt{repeat} inicia un bucle infinito; esto no se utiliza usualmente en aplicaciones estadísticas pero sí tienen sus usos. La única forma de salir de un \texttt{repeat} es llamar un \texttt{break}.
  <<comment = NA, eval = FALSE>>=
    x0 <- 1
    tol <- 1e-8
    repeat {
      x1 <- computeEstimate()
      
      if(abs(x1 - x0) < tol) {
        break
      } else {
        x0 <- x1
      }
    }
  @

    \subsubsection{\texttt{next, return}}
    \texttt{next} se usa para salir de la iteración de un bucle
    <<comment = NA>>=
        for(i in 1:100) {
          if(i <= 20){
            ## Salta las primeras 20 iteraciones
            next
          }
          ## Haga algo aquí
        }
    @
    \texttt{return} señala que una función debe salir y regresar a un valor dado.
    
  \subsection{Resumen de estructuras de control}
  \begin{itemize}
    \item Las estructuras de control como \texttt{if}, \texttt{while} y \texttt{for} permiten controlar el flujo de un programa en \texttt{R}
    \item Los bucles infinitos deben evitarse aún si son teóricamente correctos.
    \item Las estructuras de control mencionadas son principalmente utilizadas para escribir programas; para trabajar interactivamente líneas de comando, las funciones \texttt{*apply} son más utilizadas.
  \end{itemize}

\section{Primeras funciones en \texttt{R}}
<<<<<<< HEAD

A continuación algunas funciones que se escribieron inicialmente en \texttt{R}:\\

Una simple función que recibe dos objetos y los suma
  <<comment = NA>>=
  add2 <- function(x, y) {
      x + y
  }
  @

Una función que recibe un objeto, evalúa si lo que compone este objeto tiene componentes mayores a 10 y luego arroja aquellos componentes mayores a 10   
  <<comment = NA>>=
  above10 <- function(x){
        use <- x > 10
        x[use]
  }
  @

La misma función anterior pero ahora el usuario deberá suministrar el objeto y el número al cual debe evaluarse
  <<comment = NA>>=
  above <- function(x, n){
    use <- x > n
    x[use]
  }
  @

Esta función evaluará el promedio de cada columna de un objeto dado.
  <<comment = NA>>=
  columnmean <- function(y) {
    nc <- ncol(y)
    means <- numeric(nc)
      for(i in 1:nc) {
        means[i] <- mean(y[, i])
      }
    means
  }
  @

=======

A continuación algunas funciones que se escribieron inicialmente en \texttt{R}:\\

Una simple función que recibe dos objetos y los suma
  <<comment = NA>>=
  add2 <- function(x, y) {
      x + y
  }
  @

Una función que recibe un objeto, evalúa si lo que compone este objeto tiene componentes mayores a 10 y luego arroja aquellos componentes mayores a 10   
  <<comment = NA>>=
  above10 <- function(x){
        use <- x > 10
        x[use]
  }
  @

La misma función anterior pero ahora el usuario deberá suministrar el objeto y el número al cual debe evaluarse
  <<comment = NA>>=
  above <- function(x, n){
    use <- x > n
    x[use]
  }
  @

Esta función evaluará el promedio de cada columna de un objeto dado.
  <<comment = NA>>=
  columnmean <- function(y) {
    nc <- ncol(y)
    means <- numeric(nc)
      for(i in 1:nc) {
        means[i] <- mean(y[, i])
      }
    means
  }
  @

>>>>>>> 1ed43ad379b5fc490bc47c16b50adc7c3917a80f
La misma función anterior sólo que omitiremos los \texttt{NA} para que pueda evaluarse.
  <<comment = NA>>=
  columnmean2 <- function(y, removeNA = TRUE) {
    nc <- ncol(y)
    means <- numeric(nc)
      for(i in 1:nc) {
      means[i] <- mean(y[, i], na.rm = removeNA)
      }
    means
  }
  @

\section{Funciones en \texttt{R}}
Las funciones se crean con la directiva \texttt{function()} y se guardan como objetos de \texttt{R}. En particular, son objetos de \texttt{R} de clase "function".
  <<comment = NA, eval = FALSE>>=
  f <- function(<argumentos>) {
    ## Que haga algo  
  }
  @ 

Las funciones en \texttt{R} son "objetos de primera clase", que significa que pueden ser tratados como cualquier otro objeto \texttt{R}. Principalmente,
  \begin{itemize}
    \item Las funciones pueden pasar como argumentos de otras funciones
    \item Las funciones pueden estar anidadas, es decir que es posible definir una función dentro de otra función. El valor que entrega una función es la última expresión en el cuerpo de la función a ser evaluada.
  \end{itemize}
<<<<<<< HEAD
=======

  \subsection{Argumentos de las funciones}
  Las funciones tienen \emph{argumentos de nombre} los cuales potencialmente tienen \emph{valores por defecto}.
  \begin{itemize}
    \item Los \emph{argumentos formales} son los argumentos incluidos en la definición de la función.
    \item la función \texttt{formals} devuelve una lista de todos los argumentos formales de una función.
    \item No todas las funciones llamadas en R hacen uso de todos los argumentos formales
    \item Los argumentos de las funciones pueden estar \emph{perdidas} o quizás tengan valores por defecto.
  \end{itemize}
  
  \subsection{Argumentos coincidentes}
  Los argumentos de las funciones en \texttt{R} pueden coincidir en posición o en nombre. Por ende, los siguientes llamados a \texttt{sd} son todas equivalentes
  <<comment = NA, eval = FALSE>>=
    mydata <- rnorm(100)
    sd(mydata)
    sd(x = mydata)
    sd(x = mydata, na.rm = FALSE)
    sd(na.rm = FALSE, x = mydata)
    sd(na.rm = FALSE, mydata)
  @
  
  A pesar de que esto sea posible, no es recomendable manejar las funciones desordenadamente por lo que, naturalmente, causará confusión.


Es posible combinar coincidencias posicionales con coincidencias por nombre. Cuando un argumento is coincidido por nombre, éste es "sacado" de la lista de argumentos y los argumentos sin nombrar restantes se coinciden en el orden en que ellos están listados en la definición de la función.
  <<comment = NA>>=
    args(lm)
  @
>>>>>>> 1ed43ad379b5fc490bc47c16b50adc7c3917a80f

  \subsection{Argumentos de las funciones}
  Las funciones tienen \emph{argumentos de nombre} los cuales potencialmente tienen \emph{valores por defecto}.
  \begin{itemize}
    \item Los \emph{argumentos formales} son los argumentos incluidos en la definición de la función.
    \item la función \texttt{formals} devuelve una lista de todos los argumentos formales de una función.
    \item No todas las funciones llamadas en R hacen uso de todos los argumentos formales
    \item Los argumentos de las funciones pueden estar \emph{perdidas} o quizás tengan valores por defecto.
  \end{itemize}
  
  \subsection{Argumentos coincidentes}
  Los argumentos de las funciones en \texttt{R} pueden coincidir en posición o en nombre. Por ende, los siguientes llamados a \texttt{sd} son todas equivalentes
  <<comment = NA, eval = FALSE>>=
    mydata <- rnorm(100)
    sd(mydata)
    sd(x = mydata)
    sd(x = mydata, na.rm = FALSE)
    sd(na.rm = FALSE, x = mydata)
    sd(na.rm = FALSE, mydata)
  @
  
  A pesar de que esto sea posible, no es recomendable manejar las funciones desordenadamente por lo que, naturalmente, causará confusión.


  Es posible combinar coincidencias posicionales con coincidencias por nombre. Cuando un argumento is coincidido por nombre, éste es "sacado" de la lista de argumentos y los argumentos sin nombrar restantes se coinciden en el orden en que ellos están listados en la definición de la función.
  <<comment = NA>>=
    args(lm)
  @

  Los siguientes dos llamados son similares:
  <<comment = NA, eval = FALSE>>=
    lm(data = mydata, y - x, model = FALSE, 1:100)
    lm(y - x, mydata, 1:100, model = FALSE)
  @  
  
  \begin{itemize}
    \item Muchas veces los argumentos de nombre son útiles  en la línea de comandos cuando se tiene una lista de argumentos larga y se pretende usar los valores por defecto de todo excepto por un argumento cercano al final de la lista.  
    \item Los argumentos de nombre también son de ayuda si puede recordarse el nombre del argumento y no su posición en la lista de argumentos (plotting es un excelente ejemplo).
\end{itemize}

Los argumentos de las funciones también pueden ser parcialmente coincidentes, lo que es muy útil es trabajos interactivos. El orden de operaciones cuando un argumento es dado:
    \begin{enumerate}
      \item Revisa la coincidencia exacta para un argumento de nombre
      \item Revisa una coincidencia parcial
      \item Revisa una coincidencia de posición
    \end{enumerate}

  \subsection{Definiendo una función}
  Además de no especificar un valor por defecto, también es posible asignarle a un argumento el valor \texttt{'NULL'}. 
  <<comment = NA, eval = FALSE>>=
    f <- function(a, b = 1, c = 2, d = NULL){
      
    }
  @ 
  
  \subsection{Evaluación perezosa}
  Los argumentos para funciones son evaluadas \emph{perezosamente}, es decir sólo cuando son necesarias.
  <<comment = NA>>=
    f <- function(a, b){
      a^2
    }
    f(2)
  @
  Esta función no usa el argumento \texttt{b}, de tal suerte que llamar \texttt{f(2)} no producirá un error por cuanto \texttt{2} quedará ubicado posicionalmente en \texttt{a}.  
  <<comment = NA>>=
    f <- function(a, b){
      print(a)
      print(b)
    }
    f(45)
  @
  
  \subsection{El argumento "\dots"}
  El argumento "\dots" indica un número variable de argumentos que usualmente se pasan a otras funciones.
  \begin{itemize}
    \item \dots se usa comúnmente cuando se extienden otras funciones y no se quiere copiar la lista entera de argumentos de la función original.
    <<comment = NA>>=
      myplot <- function(x, y, type = "l", ...){
        plot(x, y, type = type, ...)
      }
    @  
    \item Las funciones genéricas usan \dots, así esos argumentos extra se pasan a métodos.
    <<comment = NA>>=
      mean
    @    
  \end{itemize}

  El argumento \dots también es necesario cuando el número de argumentos pasados a la función no se conoce previamente.
    <<comment = NA>>=
      args(paste)
      args(cat)
    @
  
  \subsection{Argumentos que vienen después del argumento "\dots"}
  Una captura con \dots significa que cualquier argumento que aparezca después de \dots sobre la lista de argumentos debe ser llamados explícitamente y no puede ser parcialmente coincidido.
    <<comment = NA>>=
      args(paste)
      paste("a", "b", sep = ":")
      paste("a", "b", se = ":")
    @
  
\section{Reglas de ámbito}
  \subsection{Símbolo de unión}
    \subsubsection{Una desviación en valores de unión a símbolos}
    ¿Cómo sabe \texttt{R} qué valor asignar a qué símbolo?
    <<comment = NA>>=
      lm <- function(x) {x * x}
      lm
    @
    ¿Cómo sabe \texttt{R} que valor asignar al símbolo \texttt{lm}? ¿Por qué no le da el valor de \texttt{lm} que está en la librería de \texttt{R}?

    Cuando \texttt{R} intenta enlazar un valor a un símbolo, busca a través de una serie de \texttt{entornos} para encontrar el valor apropiado. Cuando se está trabajando en la línea de comandos y se necesita recuperar el valor de un objeto en \texttt{R}, el orden es:

    \begin{enumerate}
      \item Buscar en el entorno global por un nombre de símbolo y compararlo con el solicitado.
      \item Buscar en los espacios de nombres de cada uno de los paquetes en la lista de búsqueda
    \end{enumerate}

    La lista de búsqueda se puede encontrar utilizando la función \texttt{search}.
    <<comment = NA>>=
      search()
    @
    
    \subsubsection{Valores de unión a símbolos}
    \begin{itemize}
      \item El \emph{entorno global} o espacio de trabajo del usuario siempre es el primer elemento de la lista de búsqueda y el paquete \emph{base} siempre es el último.
      \item ¡El orden de los paquetes de la lista de búsqueda sí importa!
      \item El usuario puede configurar qué paquetes deben cargarse en el arranque por lo que no puede asumirse que habrá una lista de paquetes disponibles.
      \item Cuando un usuario carga un paquete con \texttt{library}, el espacio de nombres de ese paquete se pone en la segunda posición de la lista de búsqueda (por defecto) y todo lo demás se desplaza por la lista.
      \item Tenga en cuenta que \texttt{R} tiene espacios de nombres distintos para las funciones y las que no lo son, por lo que es posible tener un objeto denominado \texttt{c} y una función también llamada \texttt{c}. 
    \end{itemize}

    \subsubsection{Reglas de ámbito}
    Las reglas de ámbito de \texttt{R} son la principal característica que lo diferencia del lenguaje original \texttt{S}.
    \begin{itemize}
      \item Las reglas de ámbito determinan cómo un valor se asocia con una variable libre en una función
      \item R utiliza \emph{ámbito léxico} o \emph{ámbito estático}. Una alternativa común es \emph{ámbito dinámico}.
      \item R usa la búsqueda list para relacionar un valor con un símbolo mediante las reglas de ámbito.
      \item El ámbito léxico resulta ser particularmente útil para simplificar los cálculos estadísticos 
    \end{itemize}
    
    \subsubsection{Ámbito léxico}
    Considere la siguiente función
    <<comment = NA>>=
      f <- function(x, y){
        x^2 + y / z
      }
    @    
    Esta función tiene dos argumentos formales \texttt{x} y \texttt{y}. En el cuerpo de la función hay otro símbolo, \texttt{z}. En este caso \texttt{z} se llama \emph{variable libre}. Las reglas de ámbito de un lenguaje determinan cómo se asignan valores a las variables libres. Las variables libres no son argumentos formales y no son variables locales (asignadas dentro del cuerpo de la función).\par
    El ámbito léxico en \texttt{R} significa que \emph{los valores de las variables libres se buscan en el entorno al cual la función fue asignada}.\\ \par
    ¿Qué es un environment?
    \begin{itemize}
      \item Un \emph{entorno} es una colección de parejas (símbolos, valores), es decir, \texttt{x} es un símbolo y \texttt{3.14} podría ser su valor.
      \item Cada entorno tiene un entorno paterno; es posible para un entorno tener varios "hijos"
      \item El único entorno sin un padre es el entorno de vacío
      \item Una función + un ambiente = un \emph{cierre} o una \emph{función cierre}.
    \end{itemize}
    
    Buscar el valor de una variable libre:
    \begin{itemize}
      \item Si el valor de un símbolo no se encuentra en el entorno en el que se define una función, entonces la búsqueda se continúa en el \emph{entorno paterno}.
      \item La búsqueda continúa por la secuencia de los entornos paternos hasta alcanzar el entorno de nivel superior; esto, por lo general, el entorno global (espacio de trabajo) o el espacio de nombres de un paquete.
      \item Después del entorno de nivel superior, la búsqueda continúa hacia abajo de la lista de búsqueda hasta llegar al entorno vacío. Si un valor para un símbolo dado no se puede encontrar una vez que se llega al entorno vacío, a continuación, se emite un error. 
    \end{itemize}

    \textbf{¿Para qué todo este asunto?}
    \begin{itemize}
      \item Por lo general, una función se define en el entorno global, por lo que los valores de variables libres solo se encuentran en el espacio de trabajo del usuario
      \item Este comportamiento es lógico para la mayoría de las personas y es por lo general lo "correcto" para hacer
      \item Sin embargo, en \texttt{R} puede haber funciones definidas dentro de otras funciones.
      \begin{itemize}
        \item Lenguajes como \texttt{C} no le permiten hacer esto
      \end{itemize}
      \item Ahora las cosas se ponen interesantes - En este caso, el entorno en el que se define una función es el cuerpo de otra función!
    \end{itemize}
    
    <<comment = NA>>=
      make.power <- function(n){
        pow <- function(x){
          x^n
        }
      }
    @        

    Esta función devuelve otra función como su valor
    <<comment = NA>>=
      cube <- make.power(3)
      square <- make.power(2)
      cube(3)
      square(3)
    @

    \subsubsection{Explorando funciones cierre}
    ¿Qué es el entorno de una función?
    <<comment = NA>>=
      ls(environment(cube))
      get("n", environment(cube))
      
      ls(environment(square))
      get("n", environment(square))
    @    
    
    \subsubsection{Ámbito léxico vs. Dinámico}
    <<comment = NA>>=
      y <- 10
      
      f <- function(x) {
        y <- 2
        y^2 + g(x)
      }

      g <- function(x) { 
        x*y
      }
    @
    
    Cuál es el valor de 
    <<comment = NA>>=
      f(3)
    @

    \begin{itemize}
      \item Con ámbito léxico el valor de \texttt{y} en la función \texttt{g} se busca en el entorno en el que se define la función, en este caso el entorno global, por lo que el valor de \texttt{y} es 10.
      \item Con ámbito dinámico, el valor de \texttt{y} se busca en el entorno del cual la función era \emph{llamada} (a veces referida como el \emph{entorno de llamado}).
      \begin{itemize}
        \item En \texttt{R} el entorno de llamado es conocido como \emph{marco paterno}.
      \end{itemize}
      \item Así que el valor de \texttt{y} sería 2.
    \end{itemize}
    
    Cuando una función se define en el entorno global y es posteriormente llamada del entorno global, entonces el entorno de la definición y el entorno de la llamada son los mismos. Esto a veces puede dar la apariencia de alcance dinámico.
    <<comment = NA>>=
      g <- function(x) { 
        a <- 3
        x + a + y 
      }
      g(2)

      y <- 3
      g(2)
    @

    \subsubsection{Otros lenguajes}
    Otros lenguajes que soportan ámbito léxico
    \begin{itemize}
      \item Scheme
      \item Perl
      \item Python
      \item Common Lisp (todos los lenguajes convergen a Lisp)
    \end{itemize}

    \subsubsection{Consecuencias del ámbito léxico}
    \begin{itemize}
      \item  En \texttt{R} todos los objetos se deben almacenar en la memoria
      \item Todas las funciones deben llevar un puntero a sus respectivos entornos de definición, que podría estar en cualquier lugar
      \item En \texttt{S-PLUS}, las variables libres siempre miran hacia el espacio de trabajo global, por lo que todo se puede almacenar en el disco debido a que el "entorno de la definición" de todas las funciones es el mismo.
    \end{itemize}

  \subsection{Aplicación: Optimización}
  ¿Por qué es útil esta información?
  \begin{itemize}
    \item Las rutinas de optimización en \texttt{R} como \texttt{optim}, \texttt{nlm} y \texttt{optimize} requiere pasar a una función cuyo argumento sea un vector de parámetros (ej. log-verosimilitud)
    \item Sin embargo, una función objeto puede depender de una serie de variables distintas a sus parámetros (como \texttt{data}) 
    \item Al escribir software que optimiza, lo deseable es que permita al usuario mantener algunos parámetros fijos.
  \end{itemize}
  
  \subsubsection{Maximizando una verosimilitud Normal}
  Escribamos una finción "cosntructor"
    <<comment = NA>>=
      make.NegLogLik <- function(data, fixed=c(FALSE, FALSE)) {
        params <- fixed
        function(p) {
          params[!fixed] <- p
          mu <- params[1]
          sigma <- params[2]
          a <- -0.5 * length(data) * log(2 * pi * sigma^2)
          b <- -0.5 * sum((data - mu)^2) / (sigma^2) 
          - (a + b)
        }
      }  
    @
  \textbf{\emph{Nota:}} Las funciones de optimización en \texttt{R} minimizan funciones, por ende se necesita usar el valor negativo de la log-verosimilitud.
    <<comment = NA>>=
      set.seed(1); normals <- rnorm(100, 1, 2)
      nLL <- make.NegLogLik(normals)
      nLL
      
      ls(environment(nLL))  
    @

  \subsection{Estimación de parámetros}
    <<comment = NA>>=
      optim(c(mu = 0, sigma = 1), nLL)$par  
    @  
  
  Fijando $\sigma = 2$
    <<comment = NA>>=
      nLL <- make.NegLogLik(normals, c(FALSE, 2))
      optimize(nLL, c(-1, 3))$minimum
    @

  Fijando $\mu = 1$
    <<comment = NA>>=
      nLL <- make.NegLogLik(normals, c(1, FALSE))
      optimize(nLL, c(1e-6, 10))$minimum
    @
  \subsection{Dibujando la verosimilitud}
      <<comment = NA>>=
      nLL <- make.NegLogLik(normals, c(1, FALSE))
      x <- seq(1.7, 1.9, len = 100)
      y <- sapply(x, nLL)
      plot(x, exp(-(y - min(y))), type = 'l')
      
      nLL <- make.NegLogLik(normals, c(FALSE, 2))
      x <- seq(0.5, 1.5, len = 100)
      y <- sapply(x, nLL)
      plot(x, exp(-(y - min(y))), type = 'l')
    @
    
  \subsection{Resumen de ámbito léxico}
  \begin{itemize}
    \item Las funciones objetivo pueden ser "construidas", para que contengan todos los datos necesarios para evaluar la función
    \item No hay necesidad de llevar a todas partes largas listas de argumentos - útil para el trabajo interactivo y exploratorio.
    \item El código puede simplificarse y limpiarse
    \item Referencia: Robert Gentleman and Ross Ihaka (2000). “Lexical Scope and Statistical Computing,” \emph{JCGS}, 9, 491–508.
  \end{itemize}

\section{Normas de codificación en \texttt{R}}
\begin{enumerate}
  \item Siempre usar archivos de texto / editor de texto.
  \item Tabular el código
  \item Limitar el ancho del código(¿80 columnas?)
  \item Limitar la longitud de funciones individuales
\end{enumerate}

\section{Fechas y horas en \texttt{R}}
\texttt{R} ha desarrollado una representación especial de fechas y horas:
\begin{itemize}
  \item Las fechas se representan mediante la clase \texttt{Date}
  \item Las horas se representan mediante las clases \texttt{POSIXct} o \texttt{POSIXlt}
  \item Las fechas se almacenan internamente como el número de días desde 1970-01-01
  \item Las horas se almacenan internamente como el número de segundos desde 1970-01-01.
\end{itemize}

  \subsection{Fechas en \texttt{R}}
  Las fechas se representan mediante la clase \texttt{Date} y puede ser obligadas a convertirse en cadenas de caracteres usando la función \texttt{as.Date()}.
  <<comment = NA>>=
    x <- as.Date("1970-01-01")
    x
    unclass(x)
    unclass(as.Date("1970-01-02"))
  @

  \subsection{Horas en \texttt{R}}
  Las horas se representan usando las clases \texttt{POSIXct} o \texttt{POSIXlt}
  \begin{itemize}
    \item \texttt{POSIXct} es sólo  un grán número entero, al fin de cuentas. Usa una clase cuando se quiere almacenar horas en algo como un data frame.
    \item \texttt{POSIXlt} es una lista que almacena una serie de información como el día de la semana, día del año, mes, día del mes.
  \end{itemize}
  
  Existe un número de funciones genéricas que trabajan con fechas y horas:
  \begin{itemize}
    \item \texttt{weekdays}: genera el día de la semana
    \item \texttt{months}: genera el nombre del mes
    \item \texttt{quarters}: genera el número del trimestre ("Q1", "Q2", "Q3" o "Q4")
  
  Las horas pueden ser obligadas a convertirse en una cadena de caracteres usando las funciones \texttt{as.POSIXct} o \texttt{as.POSIXlt}
  
  \end{itemize}
  <<comment = NA>>=
    x <- Sys.time()
    x
    p <- as.POSIXlt(x)
    names(unclass(p))
    p$sec
  @

  También es posible usar el formato \texttt{POSIXct}
  <<comment = NA>>=
    x <- Sys.time()
    x ## Ya en formato 'POSIXct'
    unclass(x)
    x$sec
    p <- as.POSIXlt(x)
    p$sec
  @

  Finalmente, existe una función \texttt{strptime} en caso de que sus fechas estén escritas en diferente formato
  <<comment = NA>>=
    datestring <- c("January 10, 2012 10:40", "December 9, 2011 9:10")
    x <- strptime(datestring, "%B %d, %Y %H: %M")
    x
    class(x)
  @  
  Es posible no recordar el formato de las cadenas. Revise \texttt{?strptime} para más detalles.
  
  \subsection{Operaciones con fechas y horas}
  Es posible usar operaciones matemáticas con fechas y horas. Realmente, sólo sumar y restar. También es posible hacer comparaciones (ej. ==, <=)
  <<comment = NA>>=
    x <- as.Date("2012-01-01")
    y <- strptime("9 Jan 2011 11:34:21", "%d %b %Y %H:%M:%S") 
    x-y
    x <- as.POSIXlt(x) 
    x-y
  @

  Incluso un seguimiento de los años bisiestos, segundos bisiestos, el horario de verano y zonas horarias
  <<comment = NA>>=
    x <- as.Date("2012-03-01") 
    y <- as.Date("2012-02-28") 
    x-y
    x <- as.POSIXct("2012-10-25 01:00:00")
    y <- as.POSIXct("2012-10-25 06:00:00", tz = "GMT") 
    y-x
  @















\end{document}
  
