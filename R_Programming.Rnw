\documentclass{article}
\usepackage[utf8]{inputenc}

\title{R Programming}
\author{Martín Macías}
\date{Diciembre de 2015}

\begin{document}

\maketitle

\section{Estableciendo el Directorio de trabajo}
La idea es hacer el seguimiento de los comandos en \texttt{R} para establecer el directorio de trabajo.\\
\begin{itemize}
  \item Con la opción \texttt{getwd()} se obtiene el directorio de trabajo actual:
    <<comment=NA>>=
      getwd()
    @

  \item Para ver los archivos  crpetas que hay en el directorio de trabajo actual:
    <<comment=NA>>=
      dir()
    @

  \item El comando \texttt{ls()} muestra lo que exista en mi espacio de trabajo:
    <<comment=NA>>=
      ls()
    @
\end{itemize}

\section{Data types}
  \subsection{Vectores y listas}
    \subsubsection{Creando vectores}
      La función \texttt{c()} se usa para crear vectores de objetos:
        <<comment=NA>>=
          x <- c(0.5, 0.6)      # Numérico
          x <- c(TRUE, FALSE)   # Lógico
          x <- c(T, F)          # Lógico
          x <- c("a", "b","c")  # Caracter
          x <- 9:29             # Entero
          x <- c(1+0i, 2+4i)    # Complejo
        @

      Usando la función \texttt{vector()}
        <<comment=NA>>=
          x <- vector("numeric", length = 10)
          x
        @

    \subsubsection{Mezclando objetos}
      Miremos cómo se mezclan objetos en un vector
        <<comment=NA>>=
          y <- c(1.7, "a")    # Caracter
          y <- c(TRUE, 2)     # Numérico
          y <- c("a", TRUE)   # Caracter
        @      

    \subsubsection{Concatenación explícita}
      Los objetos pueden concatenarse explícitamente de una clase a otra usando las         funciones \texttt{as.*}, si están disponibles:
        <<comment=NA>>=
          x <- 0:6
          class(x)
          as.numeric(x)
          as.logical(x)
          as.character(x)
        @      

      La concatenación sinsentido resulta en \texttt{NAs}
        <<comment=NA>>=
          x <- c("a", "b", "c")
          class(x)
          as.numeric(x)
          as.logical(x)
          as.complex(x)
        @ 

  \subsection{Listas}
    Las listas son tipos de vectores especiales que pueen contener elementos de           diferentes clases.
      <<comment=NA>>=
        x <- list(1, "a", TRUE, 1 + 4i)
        x
      @     

  \subsection{Matrices}
    Las matrices son vectores con un atributo de dimensión. El atributo de dimensión      es, en sí mismo, un vector entero de longitud 2 \texttt{(nrow, ncol)}
      <<comment=NA>>=
        m <- matrix(nrow = 2, ncol = 3)
        m
        dim(m)
        attributes(m)
      @     

    Las matrices se contruyen en el sentido de las columnas, es decir, en forma de       zig zag invertido
      <<comment=NA>>=
        m <- matrix(1:6, nrow = 2, ncol = 3)
        m
      @     

    Las matrices también pueden crearse directamente de vectores añadiendo el            atributo de dimensión
      <<comment=NA>>=
        m <- 1:10
        m
        dim(m) <- c(2, 5)
        m
      @         

    Las matrices también pueden crearse mediante la unión de filas \texttt{rbind()} o     la unión de columnas \texttt{cbind}
      <<comment=NA>>=
        x <- 1:3
        y <- 10:12
        cbind(x ,y)
        rbind(x, y)
      @

  \subsection{Factores}
    Los factores se usan para representar datos categóricos. Los factores pueden ser     ordenados o desordenados.
      \begin{itemize}
        \item Los factores son utilizados especialmente para modelar funciones como                \texttt{lm()} y \texttt{glm()}
        \item Usar factores con labels es mejor que usar enteros puesto que los                    factores son autodescriptivos; tener una variable que tenga como                     valores <<Masculino>> y <<Femenino>> es mejor que tener una variable                 con 1 y 2.
      \end{itemize}
      <<comment=NA>>=
        x <- factor(c("yes", "yes", "no", "yes", "no"))
        x
        table(x)    # Hace conteo de niveles que hay 
        unclass(x)  # Despoja de la clase que tenga el vector
      @

    El orden de los niveles se puede determinar usando el argumento \texttt{levels}      en \texttt{factor()}. Esto puede ser importante en modelación lineal porque el       primer nivel se usa como nivel de base.
      <<comment=NA>>=
        x <- factor(c("yes", "yes", "no", "yes", "no"), 
                    levels = c("yes", "no"))
        x
      @

  \subsection{Datos faltantes}
    Los datos faltantes se denotan por \texttt{NA} o \texttt{NaN} para operaciones       matemáticas indefinidas.
      \begin{itemize}
        \item \texttt{is.na()} se usa para probar si los objetos son \texttt{NA}
        \item \texttt{is.nan()} se usa para probar si los objetos son \texttt{NaN}
        \item Los valores \texttt{NA} también tienen clase. Pueden ser enteros                     \texttt{NA}, caracter \texttt{NA}, etc.
        \item Un valor \texttt{NaN} es también \texttt{NA} pero el recíproco no es                 cierto
      \end{itemize}
      <<comment=NA>>=
        x <- c(1, 2, NA, 10, 3)
        is.na(x)
        is.nan(x)
        x <- c(1, 2, NaN, NA, 4)
        is.na(x)
        is.nan(x)
      @

  \subsection{Data frames}
    Los data frames se usan para almacenar datos tabulados.
      \begin{itemize}
        \item Se representan como un tipo especial de lista donde cada elemento de la               lista debe tener la misma longitud.
        \item Cada elemento de la lista se puede pensar como una columna y la                      longitud de cada elemento de la lista es el número de filas.
        \item A diferencia de las matrices, los data frames pueden almacenar                       diferentes clases de objetos en cada columna (así como las listas): los               elementos de las matrices deben ser de la misma clase.
        \item Los data frames también tienen un atributo especial llamado 
              \texttt{row.names}
        \item Los data frames se crean usualmente mediante \texttt{read.table()} o                 \texttt{read.csv()}
        \item Los data frames pueden convertirse en matrices mediante 
              \texttt{data.matrix()}
      \end{itemize}
      <<comment=NA>>=
        x <- data.frame(foo = 1:4, bar = c(T, T, F, F))
        x
        nrow(x)
        ncol(x)
      @
    
  \subsection{Atributos de nombre}
    Los objetos en \texttt{R} también pueden tener nombres, los cuales son muy útiles     para esribir código legible y objetos autodescriptivos.
      <<comment=NA>>=
        x <- 1:3
        names(x)
        names(x) <- c("foo", "bar", "norf")
        x
        names(x)
      @

    Las listas también pueden tener nombres.
      <<comment=NA>>=
        x <- list(a = 1, b = 2, c = 3)
        x
      @

    Para las matrices funciona de igual forma.
      <<comment=NA>>=
        m <- matrix(1:4, nrow = 2, ncol = 2)
        dimnames(m) <- list(c("a", "b"), c("c", "d"))
        m
      @    
\section{Leer datos tabulados}
Existen unas pocas funciones principales para leer datos en \texttt{R}.
  \begin{itemize}
    \item \texttt{read.table} y \texttt{read.csv} para leer datos tabulados.
    \item \texttt{readLines} para leer líneas de texto.
    \item \texttt{source} para leer archivos de \texttt{R} (\texttt{inverse} de                \texttt{dump})
    \item \texttt{dget} para leer archivos de \texttt{R} (\texttt{inverse} de                  \texttt{dput})
    \item \texttt{load} para leer de espacios de trabajo guardados
    \item \texttt{unserialize} para leer objetos de \texttt{R} en forma binaria.
  \end{itemize}

  \subsection{\texttt{read.table}}
  La función \texttt{read.table} es una de las funciones más comúnmente usadas para    leer datos. Tienen unos pocos argumentos:
  \begin{itemize}
    \item \texttt{file}, el nombre de un archivo o conexión.
    \item \texttt{header}, tipo lógico e indica si el archivo tiene línea de cabecera
    \item \texttt{sep}, tipo cadena e indica cómo están separadas las columnas.
    \item \texttt{colClasses}, un vector de caracteres que indica la clase de cada              columna en el conjunto de datos.
    \item \texttt{nrows}, número de filas en el conjunto de datos.
    \item \texttt{comment.char}, una cadena de caracteres que indica el caracter del           comentario.
    \item \texttt{skip}, número de líneas que deben omitirse desde el principio.
    \item \texttt{stringsAsFactors}, ¿deberían las variables caracter ser codificadas          como factores?
\end{itemize}

\textbf{Nota:} \texttt{read.table} trabaja con archivos separados por espacios mientras que \texttt{read.csv} trabaja con archivos separados por comas.










\section{Conclusion}
``I always thought something was fundamentally wrong with the universe'' 
\end{document}
