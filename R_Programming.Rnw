\documentclass{article}
\usepackage[utf8]{inputenc}

\title{R Programming}
\author{Martín Macías}
\date{Diciembre de 2015}

\begin{document}

\maketitle

\section{Estableciendo el Directorio de trabajo}
La idea es hacer el seguimiento de los comandos en \texttt{R} para establecer el directorio de trabajo.\\
\begin{itemize}
  \item Con la opción \texttt{getwd()} se obtiene el directorio de trabajo actual:
    <<comment=NA>>=
      getwd()
    @

  \item Para ver los archivos  crpetas que hay en el directorio de trabajo actual:
    <<comment=NA>>=
      dir()
    @

  \item El comando \texttt{ls()} muestra lo que exista en mi espacio de trabajo:
    <<comment=NA>>=
      ls()
    @
\end{itemize}

\section{Data types}
  \subsection{Vectores y listas}
    \subsubsection{Creando vectores}
      La función \texttt{c()} se usa para crear vectores de objetos:
        <<comment=NA>>=
          x <- c(0.5, 0.6)      # Numérico
          x <- c(TRUE, FALSE)   # Lógico
          x <- c(T, F)          # Lógico
          x <- c("a", "b","c")  # Caracter
          x <- 9:29             # Entero
          x <- c(1+0i, 2+4i)    # Complejo
        @

      Usando la función \texttt{vector()}
        <<comment=NA>>=
          x <- vector("numeric", length = 10)
          x
        @

    \subsubsection{Mezclando objetos}
      Miremos cómo se mezclan objetos en un vector
        <<comment=NA>>=
          y <- c(1.7, "a")    # Caracter
          y <- c(TRUE, 2)     # Numérico
          y <- c("a", TRUE)   # Caracter
        @      

    \subsubsection{Concatenación explícita}
      Los objetos pueden concatenarse explícitamente de una clase a otra usando las funciones \texttt{as.*}, si están disponibles:
        <<comment=NA>>=
          x <- 0:6
          class(x)
          as.numeric(x)
          as.logical(x)
          as.character(x)
        @      

      La concatenación sinsentido resulta en \texttt{NAs}
        <<comment=NA>>=
          x <- c("a", "b", "c")
          class(x)
          as.numeric(x)
          as.logical(x)
          as.complex(x)
        @ 

  \subsection{Listas}
    Las listas son tipos de vectores especiales que pueen contener elementos de diferentes clases.
      <<comment=NA>>=
        x <- list(1, "a", TRUE, 1 + 4i)
        x
      @     

  \subsection{Matrices}
    Las matrices son vectores con un atributo de dimensión. El atributo de dimensión es, en sí mismo, un vector entero de longitud 2 \texttt{(nrow, ncol)}
      <<comment=NA>>=
        m <- matrix(nrow = 2, ncol = 3)
        m
        dim(m)
        attributes(m)
      @     

    Las matrices se contruyen en el sentido de las columnas, es decir, en forma de "zig zag" invertido
      <<comment=NA>>=
        m <- matrix(1:6, nrow = 2, ncol = 3)
        m
      @     

    Las matrices también pueden crearse directamente de vectores añadiendo el atributo de dimensión
      <<comment=NA>>=
        m <- 1:10
        m
        dim(m) <- c(2, 5)
        m
      @         

    Las matrices también pueden crearse mediante la unión de filas \texttt{rbind()} o la unión de columnas \texttt{cbind}
      <<comment=NA>>=
        x <- 1:3
        y <- 10:12
        cbind(x ,y)
        rbind(x, y)
      @

  \subsection{Factores}
    Los factores se usan para representar datos categóricos. Los factores pueden ser ordenados o desordenados.
      \begin{itemize}
        \item Los factores son utilizados especialmente para modelar funciones como                \texttt{lm()} y \texttt{glm()}
        \item Usar factores con labels es mejor que usar enteros puesto que los factores son autodescriptivos; tener una variable que tenga como valores <<Masculino>> y <<Femenino>> es mejor que tener una variable con 1 y 2.
      \end{itemize}
      <<comment=NA>>=
        x <- factor(c("yes", "yes", "no", "yes", "no"))
        x
        table(x)    # Hace conteo de niveles que hay 
        unclass(x)  # Despoja de la clase que tenga el vector
      @

    El orden de los niveles se puede determinar usando el argumento \texttt{levels} en \texttt{factor()}. Esto puede ser importante en modelación lineal porque el primer nivel se usa como nivel de base.
      <<comment=NA>>=
        x <- factor(c("yes", "yes", "no", "yes", "no"), 
                    levels = c("yes", "no"))
        x
      @

  \subsection{Datos faltantes}
    Los datos faltantes se denotan por \texttt{NA} o \texttt{NaN} para operaciones matemáticas indefinidas.
      \begin{itemize}
        \item \texttt{is.na()} se usa para probar si los objetos son \texttt{NA}
        \item \texttt{is.nan()} se usa para probar si los objetos son \texttt{NaN}
        \item Los valores \texttt{NA} también tienen clase. Pueden ser enteros                     \texttt{NA}, caracter \texttt{NA}, etc.
        \item Un valor \texttt{NaN} es también \texttt{NA} pero el recíproco no es                 cierto
      \end{itemize}
      <<comment=NA>>=
        x <- c(1, 2, NA, 10, 3)
        is.na(x)
        is.nan(x)
        x <- c(1, 2, NaN, NA, 4)
        is.na(x)
        is.nan(x)
      @

  \subsection{Data frames}
    Los data frames se usan para almacenar datos tabulados.
      \begin{itemize}
        \item Se representan como un tipo especial de lista donde cada elemento de la lista debe tener la misma longitud.
        \item Cada elemento de la lista se puede pensar como una columna y la longitud de cada elemento de la lista es el número de filas.
        \item A diferencia de las matrices, los data frames pueden almacenar diferentes clases de objetos en cada columna (así como las listas): los elementos de las matrices deben ser de la misma clase.
        \item Los data frames también tienen un atributo especial llamado 
              \texttt{row.names}
        \item Los data frames se crean usualmente mediante \texttt{read.table()} o                 \texttt{read.csv()}
        \item Los data frames pueden convertirse en matrices mediante 
              \texttt{data.matrix()}
      \end{itemize}
      <<comment=NA>>=
        x <- data.frame(foo = 1:4, bar = c(T, T, F, F))
        x
        nrow(x)
        ncol(x)
      @
    
  \subsection{Atributos de nombre}
    Los objetos en \texttt{R} también pueden tener nombres, los cuales son muy útiles para esribir código legible y objetos autodescriptivos.
      <<comment=NA>>=
        x <- 1:3
        names(x)
        names(x) <- c("foo", "bar", "norf")
        x
        names(x)
      @

    Las listas también pueden tener nombres.
      <<comment=NA>>=
        x <- list(a = 1, b = 2, c = 3)
        x
      @

    Para las matrices funciona de igual forma.
      <<comment=NA>>=
        m <- matrix(1:4, nrow = 2, ncol = 2)
        dimnames(m) <- list(c("a", "b"), c("c", "d"))
        m
      @    
\section{Leer datos tabulados}
Existen unas pocas funciones principales para leer datos en \texttt{R}.
  \begin{itemize}
    \item \texttt{read.table} y \texttt{read.csv} para leer datos tabulados.
    \item \texttt{readLines} para leer líneas de texto.
    \item \texttt{source} para leer archivos de \texttt{R} (\texttt{inverse} de                \texttt{dump})
    \item \texttt{dget} para leer archivos de \texttt{R} (\texttt{inverse} de                  \texttt{dput})
    \item \texttt{load} para leer de espacios de trabajo guardados
    \item \texttt{unserialize} para leer objetos de \texttt{R} en forma binaria.
  \end{itemize}

  \subsection{\texttt{read.table}}
  La función \texttt{read.table} es una de las funciones más comúnmente usadas para leer datos. Tienen unos pocos argumentos:
  \begin{itemize}
    \item \texttt{file}, el nombre de un archivo o conexión.
    \item \texttt{header}, tipo lógico e indica si el archivo tiene línea de cabecera
    \item \texttt{sep}, tipo cadena e indica cómo están separadas las columnas.
    \item \texttt{colClasses}, un vector de caracteres que indica la clase de cada columna en el conjunto de datos.
    \item \texttt{nrows}, número de filas en el conjunto de datos.
    \item \texttt{comment.char}, una cadena de caracteres que indica el caracter del comentario.
    \item \texttt{skip}, número de líneas que deben omitirse desde el principio.
    \item \texttt{stringsAsFactors}, ¿deberían las variables caracter ser codificadas como factores?
\end{itemize}

\textbf{Nota:} \texttt{read.table} trabaja con archivos separados por espacios mientras que \texttt{read.csv} trabaja con archivos separados por comas.

  \subsection{Usando \texttt{read.table}}
  El argumento \texttt{colClasses} acelera el uso de la función \texttt{read.table} hasta casi el doble. Para usar esta opción, debe conocerse la clase de cada columna de su data frame. Si todas las columnas son numéricas, por ejemplo, entonces debe ajustar el argumento así: \texttt{colClasses = "numeric"}. 
      <<comment=NA, eval = F>>=
        initial <- read.table("datatable.txt", nrows = 100)
        classes <- sapply(initial, class)
        tabAll <- read.table ("datatable.txt", colClasses = classes)
      @
  
  Si configura \texttt{nrows} podrá ahorrar memoria. Puede usar la herramienta de Unix \texttt{wc} para calcular las líneas en un archivo.
  
  \subsection{Formatos de datos textuales}
  \begin{itemize}
    \item \texttt{dumping} y \texttt{dputing} son muy útiles porque el formato textual resultante es editable y en caso de que se corrompan, potenciablemente recuperable.
    \item A diferencia de trabajar con una tabla o con un archivo csv, las funciones \texttt{dumping} y \texttt{dputing} conservan los metadatos (sacrificando algo de legibilidad) para que otro usuario no tenga que especificar todo de nuevo.  
    \item Los formatos textuales pueden trabajar mucho mejor con programas de control de versiones, los cuales pueden rastrear cambios significativos es archivos de texto.
    \item Los archivos textuales pueden ser más duraderos; en casod e que se corrompan, es más fácil hallar el problema dentro del archivo.
    \item \textbf{Desventaja:} El formato no es eficiente en cuanto a ahorro de espacio.
  \end{itemize}

  \subsection{\texttt{dput}-ing objetos en \texttt{R}}
        <<comment=NA>>=
        options(width = 55)
        y <- data.frame(a = 1, b = "a")
        dput(y)
        dput(y, file="y.R")
        new.y <- dget("y.R")
        new.y
      @
  \subsection{\texttt{dump}-ing objetos en \texttt{R}}
      <<comment=NA>>=
        x <- "foo"
        y <- data.frame(a = 1, b = "a")
        dump(c("x", "y"), file = "data.R")
        rm(x, y)
        source("data.R")
        y
        x
      @

  \subsection{Conexiones a archivos}
        <<comment = NA, echo = 2>>=
        options(width = 60)
        str(file)
      @
  \begin{itemize}
    \item \texttt{description} es el nombre del archivo.
    \item \texttt{open} es un incador de código.
      \begin{itemize}
        \item "r" para únicamente lectura
        \item "w" escritura e iniciando un nuevo archivo
        \item "a" anexar
        \item "rb", "wb", "ab" leer, escribir y anexar en modo Binario (Windows) 
      \end{itemize}
  \end{itemize}
  
  \subsection{Conexiones}
  En general, las conexiones son herramientas poderosas para navegar entre archivos u otros objetos. En la práctica, no se necesita enfrentarse directamente con la interfaz de conexión. 
      <<comment = NA, eval = F>>=
        con <- file("foo.txt", "r")
        data <- read.csv(con)
        close(con)
      @

es lo mismo que
      <<comment = NA, eval = F>>=
        data <- read.csv("foo.txt")
      @

  \subsection{Leer líneas de un archivo de texto}
      <<comment = NA, eval = F>>=
        con <- gzfile("words.gz")
        x <- readLines(con, 10)
      @
  \texttt{writeLines} toma un vector de caracteres y escribe cada elemento de una línea al tiempo en un archivo de texto.
  
  \texttt{readLines} puede ser útil para leer líneas de páginas web.
      <<comment = NA>>=
        ## Esto puede tomar algunos minutos
        con <- url("http://www.jhsph.edu", "r")
        x <- readLines(con)
        head(x)
      @

  \subsection{Subconjunto}
  Existen un gran número de operadores que pueden usarse para extraer subconjuntos de objetos en \texttt{R}. 
  \begin{itemize}
    \item \texttt{[ ]} siempre arroja un objeto de la misma clase del original; puede usarse para seleccionar más de un elemento (hay una excepción).
    \item \texttt{[[ ]]} se usa para extraer elementos de una lista o de un data frame; únicamente puede usarse un solo elemento y la clase del objeto obtenido no necesariamente es una lista o un data frame.
    \item \texttt{\$} se usa para extraer elementos de una lista o un data frame por nombre; la semántica es igual a la de \texttt{[[ ]]}.
  \end{itemize}

      <<comment = NA>>=
        x <- c("a", "b", "c", "c", "d", "a")
        x[1]
        x[2]
        x[1:4]
        x[x > "a"]
        u <- x > "a"
        u
        x[u]
      @

  \subsubsection{Listas de Subconjuntos}
      <<comment = NA>>=
        x <- list(foo = 1:4, bar = 0.6)
        x[1]
        x[[1]]
        x$bar
        x[["bar"]]
        x["bar"]
      @

      <<comment = NA>>=
        x <- list(foo = 1:4, bar = 0.6, baz = "hello")
        x[c(1, 3)]
      @

El operador \texttt{[[]]} puede usarse con índices computados; \texttt{\$} puede usarse exclusivamente con nombres literales.
      <<comment = NA>>=
        x <- list(foo = 1:4, bar = 0.6, baz = "hello")
        name <- "foo"
        x[[name]]   ## índice computado para 'foo'
        x$name      ## ¡el elemento 'name' no existe!
        x$foo
      @

\texttt{[[]]} puede tomar una secuencia de enteros.
      <<comment = NA>>=
        x <- list(a = list(10, 12, 14), b = c(3.14, 2.81))
        x[[c(1, 3)]]
        x[[1]][[3]]
        x[[c(2, 1)]]
      @

    \subsubsection{Matrices}
    De las matrices se puede crear también subconjuntos de la forma usual, con índices de la forma \textit{(i, j)}
      <<comment = NA>>=
        x <- matrix(1:6, 2, 3)
        x[1, 2]
        x[2,1]
      @
  
    U omitir los índices si se quiere:
      <<comment = NA>>=
        x[1, ]
        x[ ,2]
      @

    Por defecto, cuando un elemento solo de una matriz es recuperado, éste se retorna como un vector de longitud 1 en vez de ser una matriz de dimensión 1 x 1. Este proceder puede ser modificado mediante el argumento \texttt{drop = FALSE}
      <<comment = NA>>=
        x <- matrix(1:6, 2, 3)
        x[1, 2]
        x[1, 2, drop = FALSE]
      @

    De la misma manera, al hacer subconjuntos de una sola columna o una sola fila, el programa arrojará un vector, no una matriz (por defecto)
      <<comment = NA>>=
        x[1, ]
        x[1, , drop = FALSE]
        x[2,1]
      @

    \subsubsection{Subconjuntos con nombres}
    La coincidencia parcial de nombres se permite con \texttt{[[]]} y \texttt{\$}
      <<comment = NA>>=
        x <- list(aardvark = 1:5)
        x$a
        x[["a"]]
        x[["a", exact = FALSE]]
      @    
    
    \subsubsection{Eliminando valores faltantes}
    Una tarea común es eiminar valores faltantes \texttt{(NAS)}.
      <<comment = NA>>=
        x <- c(1, 2, NA, 4, NA, 5)
        bad <- is.na(x)
        x[!bad]
      @

    ¿Y qué pasaría si existen multiples cosas y usted quiere tomar el subconjunto con los valores no faltantes?
      <<comment = NA>>=
        x <- c(1, 2, NA, 4, NA, 5)
        y <- c("a", "b", NA, "d", NA, "f")
        good <- complete.cases(x, y)
        good
        x[good]
        y[good]
      @    

      <<comment = NA>>=
        airquality[1:6, ]
        good <- complete.cases(airquality)
        airquality[good, ][1:6, ]
      @

\section{Operaciones vectorizadas}
Muchas operaciones en \texttt[R] son \textit{vectorizadas} volviendo el código más eficiente, conciso y fácil de leer.
      <<comment = NA>>=
        x <- 1:4; y <- 6:9
        x + y
        x > 2
        x >= 2
        y == 8
        x * y
        x / y
      @
      
      <<comment = NA>>=
        x <- matrix(1:4, 2, 2); y <- matrix(rep(10, 4), 2, 2)
        x * y   ## Multiplicación término a término
        x / y
        x %*% y ## Multiplicación real de matrices
      @
\section{Conclusion}
``I always thought something was fundamentally wrong with the universe'' 
\end{document}
